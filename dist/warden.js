"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const toMessage=(e,t)=>`Expecting type '${e}'. Got type '${t}'`,toError=(e,t=[])=>({path:t,message:e}),success=e=>({success:!0,data:e}),failure=(...e)=>({success:!1,errors:e}),toResult=(e,t)=>t.length?failure(...t):success(e),mapErrorKey=(e,t)=>e.map(r=>toError(r.message,[String(t),...r.path])),isPlainObject=e=>{if(Object.prototype.toString.call(e)!=="[object Object]")return!1;const t=Object.getPrototypeOf(e);return t===null||t===Object.prototype},map=(e,t)=>r=>{const s=e(r);return s.success?t(s.data):s},string=e=>typeof e=="string"?success(e):failure(toError(toMessage("string",typeof e))),number=e=>typeof e=="number"&&Number.isFinite(e)?success(e):failure(toError(toMessage("number",typeof e))),boolean=e=>typeof e=="boolean"?success(e):failure(toError(toMessage("boolean",typeof e))),date=e=>e instanceof Date?Number.isFinite(e.getTime())?success(e):failure(toError("Expecting value to be a valid 'date'")):failure(toError(toMessage("date",typeof e))),array=e=>t=>{if(!Array.isArray(t))return failure(toError(toMessage("array",typeof t)));const r=[],s=[];for(let o=0;o<t.length;o++){const n=e(t[o]);n.success?r[o]=n.data:s.push(...mapErrorKey(n.errors,o))}return toResult(r,s)},object=e=>{const t=Object.entries(e);return r=>{if(!isPlainObject(r))return failure(toError(toMessage("object",typeof r)));const s=Object.create(null),o=[];for(const[n,u]of t){const a=u(r[n]);a.success?s[n]=a.data:o.push(...mapErrorKey(a.errors,n))}return toResult(s,o)}},literal=e=>{if(!(typeof e=="string"||typeof e=="number"||typeof e=="boolean"||e===null))throw new TypeError("'constant' literal should be of type 'string | number | boolean | null'");return t=>e===t?success(t):failure(toError(`Expecting literal '${e}'. Got '${t}'`))},nullable=e=>t=>t===null?success(t):e(t),optional=e=>t=>typeof t=="undefined"?success(t):e(t),enums=e=>{const t=Object.values(e);return r=>t.includes(r)?success(r):failure(toError(`Expecting value to be '${t.join(" | ")}'. Got '${r}'`))},tuple=(...e)=>t=>{if(!Array.isArray(t))return failure(toError(toMessage("array",typeof t)));if(t.length<e.length)return failure(toError(`Expecting 'array' to have at least '${e.length}' items on it. Got '${t.length}'`));const r=[],s=[];for(let o=0;o<e.length;o++){const n=e[o](t[o]);n.success?r[o]=n.data:s.push(...mapErrorKey(n.errors,o))}return toResult(r,s)},union=(...e)=>t=>{const r=[];for(const s of e){const o=s(t);if(o.success)return o;r.push(...o.errors)}return failure(...r)},any=e=>success(e),asString=e=>string(String(e)),asNumber=e=>number(Number(e)),asDate=e=>((typeof e=="string"||typeof e=="number")&&(e=new Date(e)),date(e));exports.any=any,exports.array=array,exports.asDate=asDate,exports.asNumber=asNumber,exports.asString=asString,exports.boolean=boolean,exports.date=date,exports.enums=enums,exports.failure=failure,exports.literal=literal,exports.map=map,exports.nullable=nullable,exports.number=number,exports.object=object,exports.optional=optional,exports.string=string,exports.success=success,exports.toError=toError,exports.tuple=tuple,exports.union=union;
