const l=(t,e)=>`Expecting type '${t}'. Got type '${e}'`,c=(t,e=[])=>({path:e,message:t}),a=t=>({success:!0,data:t}),s=(...t)=>({success:!1,errors:t}),p=(t,e)=>e.length?s(...e):a(t),f=(t,e)=>t.map(r=>c(r.message,[String(e),...r.path])),d=t=>{if(Object.prototype.toString.call(t)!=="[object Object]")return!1;const e=Object.getPrototypeOf(t);return e===null||e===Object.prototype},h=(t,e)=>r=>{const o=t(r);return o.success?e(o.data):o},y=t=>typeof t=="string"?a(t):s(c(l("string",typeof t))),b=t=>typeof t=="number"&&Number.isFinite(t)?a(t):s(c(l("number",typeof t))),j=t=>typeof t=="boolean"?a(t):s(c(l("boolean",typeof t))),g=t=>t instanceof Date?Number.isFinite(t.getTime())?a(t):s(c("Expecting value to be a valid 'date'")):s(c(l("date",typeof t))),O=t=>e=>{if(!Array.isArray(e))return s(c(l("array",typeof e)));const r=[],o=[];for(let n=0;n<e.length;n++){const u=t(e[n]);u.success?r[n]=u.data:o.push(...f(u.errors,n))}return p(r,o)},E=t=>{const e=Object.entries(t);return r=>{if(!d(r))return s(c(l("object",typeof r)));const o=Object.create(null),n=[];for(const[u,m]of e){const i=m(r[u]);i.success?o[u]=i.data:n.push(...f(i.errors,u))}return p(o,n)}},$=t=>{if(!(typeof t=="string"||typeof t=="number"||typeof t=="boolean"||t===null))throw new TypeError("'constant' literal should be of type 'string | number | boolean | null'");return e=>t===e?a(e):s(c(`Expecting literal '${t}'. Got '${e}'`))},v=t=>e=>e===null?a(e):t(e),A=t=>e=>typeof e=="undefined"?a(e):t(e),G=t=>{const e=Object.values(t);return r=>e.includes(r)?a(r):s(c(`Expecting value to be '${e.join(" | ")}'. Got '${r}'`))},N=(...t)=>e=>{if(!Array.isArray(e))return s(c(l("array",typeof e)));if(e.length<t.length)return s(c(`Expecting 'array' to have at least '${t.length}' items on it. Got '${e.length}'`));const r=[],o=[];for(let n=0;n<t.length;n++){const u=t[n](e[n]);u.success?r[n]=u.data:o.push(...f(u.errors,n))}return p(r,o)},S=(...t)=>e=>{const r=[];for(const o of t){const n=o(e);if(n.success)return n;r.push(...n.errors)}return s(...r)},w=t=>a(t),D=t=>y(String(t)),F=t=>b(Number(t)),P=t=>((typeof t=="string"||typeof t=="number")&&(t=new Date(t)),g(t));export{w as any,O as array,P as asDate,F as asNumber,D as asString,j as boolean,g as date,G as enums,s as failure,$ as literal,h as map,v as nullable,b as number,E as object,A as optional,y as string,a as success,c as toError,N as tuple,S as union};
